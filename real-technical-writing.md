# Git Objects: Git의 내부 구조 파헤치기

**대상 독자**: 이 글은 Git의 기본 명령어(`add`, `commit` 등)는 익숙하지만, Git이 내부적으로 어떻게 커밋을 저장하고 관리하는지 궁금한 개발자를 대상으로 합니다.

## 들어가며

이런 경험 있으신가요? git log에서 본 긴 해시값이 무엇인지, git commit --amend를 쓰면 왜 커밋 ID가 바뀌는지 궁금했던 적이요. 이 글을 읽고 나면 이 모든 질문에 답할 수 있게 됩니다.

이 글에서는 Git의 핵심 구성 요소인 **Commit**, **Tree**, **Blob** 객체를 직접 살펴보며 Git의 내부 동작 원리를 이해해 보겠습니다.

## Git도 파일 시스템이다

리눅스에서 "모든 것은 파일이다"라는 철학을 들어보셨을 것입니다. 실제로 Git도 같은 원리로 동작합니다. Git은 커밋을 포함한 모든 데이터를 파일로 관리하며, **Content-addressable file system**(내용 기반 주소 파일 시스템)으로 분류됩니다.

### 내용 기반 주소 파일 시스템이란?

Git은 파일 내용을 기반으로 **SHA-1 알고리즘**을 사용하여 해시값을 생성하고, 이를 주소로 사용합니다. SHA-1 알고리즘의 주요 특징은 다음과 같습니다:

- 어떤 입력값이든 40자리 고정 길이의 해시값을 출력
- 입력값이 조금만 변경되어도 완전히 다른 해시값을 생성

우리가 자주 보는 **커밋 ID**가 바로 이 해시값입니다. 커밋 ID는 커밋 객체의 내용을 통해 생성된 해시값이며, 이 글을 읽고 나면 이 개념이 자연스럽게 이해될 것입니다.

> 참고: Git은 현재 SHA-1을 사용하지만, 보안상의 이유로 SHA-256으로 전환하고 있습니다. 하지만 기본 원리는 동일하므로 이 글에서는 SHA-1을 기준으로 설명합니다.

## .git 디렉터리 생성하기

본격적으로 Git 저장소를 만들어 보겠습니다. Git 저장소를 초기화하려면 `git init` 명령어를 실행합니다:

```bash
$ git init
Initialized empty Git repository in /Users/norang/tecotalk/.git
```

명령어를 실행하면 현재 디렉터리 아래에 **.git** 폴더가 생성됩니다. 이 디렉터리가 Git의 핵심이며, 모든 Git 작업이 이 폴더 내에서 관리됩니다.

.git 디렉터리의 내부 구조를 살펴보면 다양한 파일과 폴더들이 있습니다:

```bash
$ tree -L 1 .git
.git
├── HEAD
├── config
├── description
├── hooks/
├── info/
├── objects/
└── refs/
```

오늘 살펴볼 **커밋(Commit)**, **트리(Tree)**, **블랍(Blob)** 세 가지 Git 객체와 관련된 파일은 모두 **objects** 디렉터리 하위에서 관리됩니다. 아직 커밋이 생성되지 않았기 때문에 이 폴더는 비어 있습니다. 이제 첫 번째 커밋을 생성하여 어떤 변화가 일어나는지 확인해 보겠습니다.

## 첫 번째 커밋: 하나의 파일 생성

첫 번째 커밋으로 파일 하나를 생성하고, `objects` 디렉터리에 어떤 변화가 일어나는지 살펴보겠습니다:

```bash
$ echo "우테코 최고" > first.txt
$ git add .
$ git commit -m "첫 번째 커밋"
[main (root-commit) 3202a62] 첫 번째 커밋
 1 file changed, 1 insertion(+)
 create mode 100644 first.txt
```

"우테코 최고"라는 내용을 담은 `first.txt` 파일을 생성하고 커밋했습니다. 이제 `objects` 디렉터리를 확인해 보겠습니다:

```bash
$ tree .git/objects
.git/objects
├── 32
│   └── 02a624bf70b82378936d2af3ebce710beb4687
├── 67
│   └── 6084036af8b4c710c89826d89f5aca179840d0
├── d1
│   └── 28796a5a4b31c68f9647ce08ec451cbb550916
├── info
└── pack
6 directories, 3 files
```

이전에는 없던 3개의 폴더와 각 폴더 아래 파일이 하나씩 생성되었습니다. 이 파일들이 바로 **Git 객체**를 저장하는 파일들입니다. 파일 이름은 해시값으로 구성되어 있으며, 40자리 해시값 중 앞 2자리는 폴더명으로, 나머지 38자리는 파일명으로 사용됩니다.

### Git 객체의 타입 확인하기

`git cat-file -t` 명령어를 사용하면 객체 파일의 타입을 확인할 수 있습니다. 해시값 전체를 입력할 수도 있고, 앞 4자리만 입력해도 됩니다:

```bash
$ git cat-file -t 3202a624bf70b82378936d2af3ebce710beb4687
commit
$ git cat-file -t 6760
tree
$ git cat-file -t d128
blob
```

세 파일이 각각 **commit**, **tree**, **blob**이라는 타입을 가진 것을 확인할 수 있습니다. 이제 각 객체의 내용을 자세히 살펴보겠습니다.

### Commit 객체

`git cat-file -p` 명령어로 commit 객체의 내용을 출력해 보겠습니다:

```bash
$ git cat-file -p 3202
tree 676084036af8b4c710c89826d89f5aca179840d0
author norang <norang@gmail.com> 1741103661 +0900
committer norang <norang@gmail.com> 1741103661 +0900

첫 번째 커밋
```

커밋 객체는 다음과 같은 정보를 포함합니다:

- **첫 번째 줄**: 커밋이 참조하는 트리의 SHA-1 해시값
- **두 번째 줄**: 커밋을 생성한 사람의 정보와 생성 시점
- **세 번째 줄**: 커밋을 저장소에 추가한 사람의 정보와 생성 시점
- **마지막 줄**: 커밋 메시지

"커밋은 스냅샷이다"라는 말을 들어보셨을 것입니다. 객체의 관점에서 보면, **커밋은 트리를 참조하는 객체**라고 이해할 수 있습니다.

![image.png](./image/image.png)

### Tree 객체

이제 커밋이 참조하는 tree 객체를 살펴보겠습니다:

```bash
$ git cat-file -p 6760
100644 blob d128796a5a4b31c68f9647ce08ec451cbb550916 first.txt
```

트리 객체의 각 줄은 다음 정보를 포함합니다:

- **첫 번째 부분** (100644): 객체 파일의 타입과 권한
- **두 번째 부분** (blob): 참조하는 객체의 타입 (blob 또는 tree)
- **세 번째 부분** (d128...): 참조하는 객체의 SHA-1 해시값
- **네 번째 부분** (first.txt): 파일명 또는 디렉터리명

**트리는 디렉터리를 표현하는 객체**입니다. 실제 디렉터리가 파일이나 하위 디렉터리를 포함할 수 있듯이, 트리는 블랍(blob)이나 다른 트리를 참조할 수 있습니다.

![image.png](./image/image%20copy.png)

### Blob 객체

마지막으로 blob 객체의 내용을 확인해 보겠습니다:

```bash
$ git cat-file -p d128
우테코 최고
```

**블랍은 파일의 내용을 저장하는 객체**입니다. 블랍 객체의 내용을 읽으면 해당 파일의 내용을 확인할 수 있습니다. 주목할 점은 블랍 안에는 파일 이름이나 권한 같은 메타데이터가 없다는 것입니다. 이러한 정보는 모두 트리 객체에 포함되어 있습니다.

![image.png](./image/image%20copy%202.png)

### Git 객체 요약

첫 번째 커밋을 통해 다음을 알 수 있습니다:

- **커밋은 트리를 참조하는 객체다**
- **트리는 디렉터리를 표현하는 객체다** (다른 트리나 블랍을 참조 가능)
- **블랍은 파일의 내용을 저장하는 객체다**
- **Git 객체들은 내용을 기반으로 생성된 해시값을 키로 사용한다**

## 두 번째 커밋: 서브 디렉터리 추가

두 번째 커밋에서는 서브 디렉터리를 추가하여 구조가 어떻게 변화하는지 확인해 보겠습니다. `mydir`이라는 디렉터리를 만들고 그 아래 "Hello World"라는 내용을 가진 `second.txt` 파일을 생성합니다:

```bash
$ mkdir mydir
$ echo "Hello World" > mydir/second.txt
$ tree
.
├── first.txt
└── mydir
    └── second.txt

2 directories, 2 files
```

현재 파일 구조는 다음과 같습니다:

![image.png](./image/image%20copy%203.png)

이제 변경사항을 커밋합니다:

```bash
$ git add .
$ git commit -m "두 번째 커밋"
[main e8329a0] 두 번째 커밋
1 file changed, 1 insertion(+)
create mode 100644 mydir/second.txt
```

### 커밋은 부모 커밋을 참조한다

두 번째 커밋 객체의 내용을 확인해 보겠습니다:

```bash
$ git cat-file -p e832
tree 41da861c0a215eb8cf4efb3aa0f83c245f592be5
parent 3202a624bf70b82378936d2af3ebce710beb4687
author norang <norang@gmail.com> 1741105670 +0900
committer norang <norang@gmail.com> 1741105670 +0900

두 번째 커밋
```

첫 번째 커밋과 비교하면 **parent** 라인이 추가된 것을 확인할 수 있습니다. 이를 통해 **커밋은 이전 커밋을 부모 커밋으로 참조**한다는 것을 알 수 있습니다. 첫 번째 커밋은 **root 커밋**이기 때문에 부모가 없었던 것입니다.

![image.png](./image/image%20copy%204.png)

### 트리의 계층 구조

새로 생성된 트리 객체를 살펴보겠습니다:

```bash
$ git cat-file -p 41da
100644 blob d12879... first.txt
040000 tree 8305df... mydir
```

두 번째 커밋의 트리는 두 개의 항목을 포함합니다:

- 기존의 `first.txt` 블랍 (d128...)
- 새로운 서브 디렉터리를 나타내는 트리 (8305...)

서브 디렉터리의 트리 내용도 확인해 보겠습니다:

```bash
$ git cat-file -p 8305
100644 blob 557db0... second.txt
$ git cat-file -p 557d
Hello World
```

트리가 또 다른 트리를 참조하는 계층 구조를 확인할 수 있습니다. 중요한 점은 **변경사항이 없는 파일**(first.txt)의 경우 블랍을 새로 만들지 않고 **기존 블랍을 재사용**한다는 것입니다.

![image.png](./image/image%20copy%205.png)

## 세 번째 커밋: 기존 파일 수정

이번에는 기존 파일을 수정했을 때 어떤 변화가 일어나는지 살펴보겠습니다. 처음에 만든 `first.txt` 파일에 두 번째 줄을 추가합니다:

```bash
$ echo "Hello git" >> first.txt
$ cat first.txt
우테코 최고
Hello git
```

변경사항을 커밋합니다:

```bash
$ git add .
$ git commit -m "세 번째 커밋"
[main 751b41f] 세 번째 커밋
1 file changed, 1 insertion(+)
```

새 커밋 객체를 확인해 보겠습니다:

```bash
$ git cat-file -p 751b
tree d6703a13f9cc12435bf9735e1b07c3cfccdb32f9
parent e8329a0f95a08f30a183435d98dc6eb5fcb4d2d0
author norang <norang@gmail.com> 1741107022 +0900
committer norang <norang@gmail.com> 1741107022 +0900

세 번째 커밋
```

![image.png](./image/image%20copy%206.png)

### 파일 변경 시 새로운 블랍 생성

세 번째 커밋의 트리를 살펴보겠습니다:

```bash
$ git cat-file -p d670
100644 blob 582e9c... first.txt
040000 tree 8305df... mydir
```

주목할 점은 `first.txt`의 해시값이 변경되었다는 것입니다. 처음 생성된 블랍은 `d128`이었지만, 이제는 `582e9c`로 시작하는 새로운 블랍이 생성되었습니다. 새 블랍의 내용을 확인해 보겠습니다:

```bash
$ git cat-file -p 582e
우테코 최고
Hello git
```

반면, 변경되지 않은 `mydir`은 여전히 기존 트리 `8305`를 참조하고 있습니다. 이를 통해 **파일이 변경될 경우 기존 파일을 재사용하지 않고 새로운 블랍을 생성**한다는 것을 알 수 있습니다.

## Git Objects 정리

![image.png](./image/image%20copy%207.png)

세 번의 커밋을 통해 배운 내용을 정리하면 다음과 같습니다:

- **커밋은 하나의 스냅샷을 표현하는 객체다**
- **커밋은 트리를 참조한다**
- **커밋은 이전 커밋을 부모 커밋으로 참조한다** (root 커밋 제외)
- **트리는 디렉터리를 표현하는 객체다**
- **트리는 블랍 또는 다른 트리를 참조한다**
- **블랍은 파일의 내용을 저장하는 객체다**
- **파일에 변경사항이 있을 경우 블랍이 새로 생성된다**
- **변경사항이 없는 경우 기존 트리와 블랍을 재사용한다**

## 실무에 적용하기: git commit --amend의 비밀

이제 실무에서 자주 접하는 상황을 Git 객체의 관점에서 이해해 보겠습니다.

`git commit --amend` 명령어는 가장 최근 커밋의 메시지를 변경할 수 있는 유용한 명령어입니다. 하지만 이 명령어를 사용하면 **커밋 ID가 변경**되며, 따라서 원격 저장소에 푸시된 커밋에는 사용하지 말라고 배웠을 것입니다.

왜 단순히 커밋 메시지만 수정했는데 커밋 ID가 변경될까요?

오늘 배운 내용을 떠올려 보면 답은 명확합니다. 커밋 ID는 커밋 객체의 **내용을 기반으로 생성된 해시값**입니다. 커밋 객체에는 커밋 메시지가 포함되어 있으므로, 메시지가 변경되면 커밋 객체의 내용이 바뀌고, 따라서 SHA-1 알고리즘에 의해 완전히 다른 해시값(커밋 ID)이 생성됩니다.

이것이 Git이 **내용 기반 주소 파일 시스템**으로 동작하는 결과입니다.

## 마치며

이 글에서는 Git의 핵심 객체인 Commit, Tree, Blob을 직접 살펴보며 Git의 내부 동작 원리를 이해했습니다. 처음 언급했던 두 가지 핵심 개념, "모든 것은 파일이다"와 "내용 기반 주소를 생성해서 사용하는 파일 시스템"이 이제 명확해졌을 것입니다.

Git 객체에 대한 이해는 다음과 같은 도움을 줍니다:

- Git 명령어가 내부적으로 어떻게 동작하는지 이해
- Git의 설계 철학과 동작 방식 이해
- Git 관련 문제 발생 시 더 깊이 있는 트러블슈팅 가능

더 깊이 있는 학습을 원한다면 다음 자료들을 참고하시기 바랍니다:

- 계주성, 『토미의 Git With 소스트리』, BOOKK, 2022
- [Git 공식 문서 - Git Internals](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)

터미널을 열고 직접 명령어를 입력하며 Git 객체를 탐험해 보시기 바랍니다. 실습을 통해 Git의 내부 구조를 더욱 깊이 이해할 수 있을 것입니다.
